# 进程与线程

![操作系统](https://qraffa-1304595678.cos.ap-guangzhou.myqcloud.com/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.png)

## 进程

进程是运行中的程序。程序是存储在磁盘上的一些指令和数据。

操作系统通过让一个进程只运行一段时间，然后切换到其他进程，即CPU时分共享，来实现cpu虚拟化。

进程需要的资源：CPU、内存、寄存器、文件IO资源

进程的创建：操作系统将存储在磁盘上的程序，包括代码和静态数据等，读取并加载到该进程所拥有的内存地址空间中。在准备好资源后，从入口处(比如main())开始启动程序。

### 进程状态

- 初始：进程正在被创建

- 就绪：进程已经准备好资源，但OS未执行该进程
- 运行：进程获得CPU资源，正在执行指令
- 阻塞：一个进程发生了某些操作，进入阻塞状态，直到发生其他事件时，才回到就绪状态
- 终止：进程已经结束执行，但尚未被回收，允许其他进程检查该进程的执行情况。最终将被OS回收该进程的所有相关资源。

![image-20220704153516288](https://qraffa-1304595678.cos.ap-guangzhou.myqcloud.com/img/image-20220704153516288.png)

### 进程切换

执行进程间切换操作需要由OS来执行，因此OS需要重新获得CPU的控制权

**协作方式：**OS通过等待，当用户进程触发**系统调用**，比如打开读取文件；或者用户进程执行了某些**非法操作**，比如0作为除数，访问了非法内存，此时OS将重新获得CPU的控制权

**非协作方式：**OS通过启动时钟，时钟设备可以以一定间隔时间来触发时钟中断，当时钟中断触发时，当前正在运行的进程停止，而OS的中断处理程序运行，此时OS将重新获得CPU的控制权

**上下文切换：**当OS决定进行进程执行切换时，首先为当前正在执行的进程保存它的寄存器的值，然后为接下来需要执行的进程恢复它的寄存器的值，然后OS从陷阱返回，则可以执行新调度的进程。

### 进程调度

- 先进先出(FIFO)：根据进程请求CPU的顺序依次执行。

  特点：

  - 实现简单，易于实现。
  - 存在护航效应问题，一些耗时较少的任务排在耗时长的任务之后，导致平均等待时间变长

- 最短任务优先(SJF)：根据任务的执行时间，先允许最短的，然后次短，依次下去

  特点：

  - 在不可抢占调度方式中，一旦任务执行就需要等待其完成，平均等待时间仍然可能很长

- 最短完成时间优先(STCF)：每当新工作进入系统时，会确认剩余运行时间最短的工作，然后调度该工作

  特点：

  - 长任务的响应时间长，需要等待短任务的执行完成
  - 长任务可能难以得到CPU，而饿死

- 轮转(RR)：在一个时间片时间内，只运行一个任务，然后到下一个时间片，运行下一个任务，而不是一直等待一个任务直到其完成

  特点：

  - 时间片长度的选择非常重要
  - 在任务切换时存在上下文切换等开销

- 多级响应队列(MLFQ)：设置多级队列，每个队列有不同的优先级，在任一时刻，一个任务只能处在一个优先级队列中。MLFQ总是先运行优先级高的任务，在同一优先级中的多个任务采用轮转方式调度。在不同优先级队列中的时间配额不一样，往往优先级越高时间配额越小，优先级越低则越大，因为处在优先级低队列的任务往往是CPU密集型任务。

  MLFQ的运行规则：

  1. 如果任务A优先级 > 任务B优先级，则运行任务A
  2. 如果任务A优先级 = 任务B优先级，则轮转调度任务A和B
  3. 新任务进入系统时，总是加入到最高优先级(有些会让OS处于最高优先级，用户任务最高只能处于次高的优先级)
  4. 一旦任务用完了其在该队列上的时间配额，无论中间主动放弃CPU多少次，都将其优先级降低，移动到下一级队列中
  5. 经过一定时间S后，需要将所有任务重新加入到最高优先级，以防止在最低优先级的长任务无法得到CPU而饿死

### 进程间通信

- 匿名管道

  半双工的缓冲区,只能在父子进程或兄弟进程之间通信

- 有名管道FIFO

  有名管道的文件形式存在于文件系统中,只要能访问该文件的进程,都可以实现相互之间的通信

- 消息队列

  存放在内核中的消息链表,每个消息队列由消息队列标识符表示.

  消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达.

  消息可以随机查询.

- 信号

  信号可以在任何时候发给某一进程,用于通知接收进程某个事件已经发生

- 信号量

  信号量是一个计数器，用于多进程对共享数据的访问

  它不以传送数据为主要目的，它主要是用来保护共享资源，使得资源在一个时刻只有一个进程独享

- 共享内存

  多个进程可以可以直接读写同一块内存空间

  需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥

- 套接字

  主要用于不同机器之间的进程通信

  支持 TCP/IP 的网络通信的基本操作单元

### 僵尸进程和孤儿进程

**僵尸进程:**如果子进程退出了,当它的父进程并没有处理该进程的相关状态信息,那么操作系统会为该进程保留进程描述符信息,这样的进程就是僵尸进程.

**孤儿进程:**如果父进程在子进程之前退出了,那么这个进程就是孤儿进程

**孤儿进程的处理:**unix中孤儿进程会交给init进程来管理,回收信息.

**僵尸进程的危害与处理:**

危害:当系统中存在大量的僵尸进程,就会占用大量的进程描述符,进程ID,操作系统因此受限无法继续创建新的进程.

处理:僵尸进程出现的根本原因在于它的父进程不作为,不回收它的信息.因此我们只要想办法找个靠谱的父进程来回收它的信息就行了.因此我们把产生僵尸进程的进程也就是僵尸进程的父进程杀死,那么这样这些僵尸进程就成为了孤儿进程,然后孤儿进程是会被init进程所接管的.

`init进程会例行调用wait()来检查其子进程,清除所有与其相关的僵尸进程.`

## 线程

### 并发

- 临界区：指访问共享资源的一段代码，共享资源通常是一个变量或数据结构
- 竞态条件：出现在多个线程同时进入临界区时，都试图更新共享的数据结构，导致错误的结果
- 不确定性：程序由一个或多个竞态条件组成，因此程序的输出因运行而异，这将导致程序的运行结果是不确定的
- 互斥执行：保证只有一个线程进入临界区，从而避免出现竞态，并产生确定的程序输出

#### 锁实现

**控制中断：**在进入临界区之前关闭中断，这样就能保证临界区的代码是原子地执行的。在临界区代码结束后，再开启中断。

但该方法缺点比较多：

1. 需要用户线程执行特权操作，因为需要关闭和打开中断
2. 用户线程需要独享CPU，而且操作系统还无法中断，也就可能无法重新获得CPU控制权
3. 在多处理器环境下，不同的线程运行在不同的CPU上，即使关闭中断也无济于事
4. 关闭中断会导致中断丢失，带来其他问题
5. 执行效率低

**TestAndSet：**通过硬件提供的原子操作TestAndSet指令实现

```C
int TestAndSet(int *old_ptr, int new) {
    int old = *old_ptr;
    *old_ptr = new;
    return old;
}
```

原子地执行，返回old_ptr指向的旧值， 同时更新为new的新值。

通过TestAndSet实现自旋锁：

```c
typedef struct lock_t {
    int flag;
} lock_t;

void init(lock_t *lock) {
    lock->flag = 0;
}

void lock(lock_t *lock) {
    while(TestAndSet(&lock->flag, 1) == 1)
        ; // spin
}

void unlock(lock_t *lock) {
    lock->flag = 0;
}
```

- 当一个线程在运行，调用lock()后，由于没有其他线程持有锁，此时flag为0，因此调用TestAndSet后，返回0，跳出while循环，获得锁，同时将flag原子的设置为1，标记锁已经被持有了。临界区结束后，调用unlock()将flag置为0。
- 当一个线程已经持有锁了，此时flag为1，另一线程调用lock()，然后调用TestAndSet()将返回1，因此该线程会一直自旋直到获得锁。

自旋锁不提供任何公平性保证，因此有可能有线程一直自旋。在单处理器上，还需要抢占式调度来中断自旋线程的执行，否则自旋线程永远不会放弃CPU。

**CompareAndSwap**：通过硬件提供的原子操作CompareAndSwap指令实现

```c
int CompareAndSwap(int *ptr, int expected, int new) {
    int actual = *ptr;
    if (actual == expected)
        *ptr = new;
    return actual;
}
```

原子地执行，比较ptr执行的值是否和expected相等；如果相等则更新ptr指向的值为new，否则什么也不做；不论比较成功与否，都会返回ptr指向的值。

通过CompareAndSwap实现自旋锁，其他部分和TestAndSet实现一样，只是更改lock函数：

```c
void lock(lock_t *lock) {
    while(CompareAndSwap(&lock->flag, 0, 1) == 1)
        ; // spin
}
```

**FetchAndAdd：**通过硬件提供的原子操作FetchAndAdd指令实现

```c
int FetchAndAdd(int *ptr) {
    int old = *ptr;
    *ptr = old + 1;
    return old;
}
```

原子地执行，返回ptr指向的地址的旧值，并且让该值自增1

通过FetchAndAdd实现自旋锁：

```c
typedef struct lock_t {
    int ticket;
    int turn
} lock_t;

void init(lock_t *lock) {
    lock->flag = 0;
    lock->turn = 0;
}

void lock(lock_t *lock) {
    int myturn = FetchAndAdd(&lock->ticket);
    while(lock->turn != myturn)
        ; // spin
}

void unlock(lock_t *lock) {
    FetchAndAdd(&lock->turn);
}
```

- 当一个线程在运行，调用lock()后，由于没有其他线程持有锁，此时ticket和turn都为0，因此调用FetchAndAdd(&lock->ticket)后，返回0，跳出while循环，获得锁，并且ticket更新为1。
- 当一个线程已经持有锁了，此时ticket为1，turn为0，另一线程调用lock()，然后调用FetchAndAdd(&lock->ticket)将返回1，因此该线程会一直自旋。然后前一个获得锁的线程调用unlock()释放锁，调用FetchAndAdd(&lock->turn)将turn更新为1，此时该自旋线程可以跳出while循环，获得锁。

使用FetchAndAdd方法可以保证所有线程都能抢到锁，只要一个线程获得了ticket值，最终就会被调度，就像排队取号一样。

上述硬件实现的自旋锁，带来的问题是浪费CPU时间片。

解决自旋浪费CPU的问题：

- 主动让出CPU：当要自旋的时候，放弃CPU。存在较大的上下文切换开销，线程可能一直在让出CPU而饿死。

- 队列保存等待的锁的线程：在线程获取不到锁时，主动休眠加入队列中，当有线程释放锁时，唤醒队列队首的线程。
- 两阶段锁：第一阶段先自旋一定时间或一定次数，尝试获取锁；在第一阶段自旋没有获得锁的情况下，第二阶段调用线程进入休眠，直到锁可用。

#### 条件变量

条件变量通过一个队列，当某些状态不满足条件时，线程可以将自己加入到队列中以等待(wait)该条件，当某些线程改变了该状态后，可以主动唤醒(signal)一个或多个正在等待的线程。

```c
int done = 0;
pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t c = PTHREAD_COND_INITIALIZER;

void thr_exit() {
    Pthread_mutex_lock(&m);
    done = 1;
    Pthread_cond_signal(&c);
    Pthread_mutex_unlock(&m);
}

void* child(void* arg) {
    printf("child\n");
    thr_exit();
    return NULL;
}

void thr_join() {
    Pthread_mutex_lock(&m);
    while (done == 0)
        Pthread_cond_wait(&c, &m);
    Pthread_mutex_unlock(&m);
}

int main(int argc, char* argv[]) {
    printf("parent: begin\n");
    pthread_t p;
    Pthread_create(&p, NULL, child, NULL);
    thr_join();
    printf("parent: end\n");
    return 0;
}
```

#### 信号量

信号量是一个有整数值的对象，通过两种函数来操作该变量：

- P()：将信号量的整数值减一，然后判断，如果该值为负数，即小于零，则休眠等待
- V()：将信号量的整数值加一，如果存在等待的线程，则唤醒一个

**使用信号量实现锁**

信号量初始值设置为1，加锁时调用P()，解锁时调用V()

```c
void lock_init() {
  sem_init(&lock, 0, 1);
}

void lock() {
  P(&lock);
}

void unlock() {
	V(&lock);
}
```

**使用信号量实现生产者-消费者**

```c
sem_t empty;
sem_t fill;
sem_t mutex;

void producer() {
  int i;
  for (i=0;i<loops;i++) {
    P(&empty);
  	P(&mutex);
    put(i);
    V(&mutex);
    V(&fill);
  }
}

void consumer() {
  int i;
  for (i=0;i<loops;i++) {
    P(&fill);
  	P(&mutex);
    put(i);
    V(&mutex);
    V(&empty);
  }
}

void init() {
  sem_init(&empty, 0, MAX); // buffer
  sem_init(&fill, 0, 0);
  sem_init(&mutex, 0, 1);
}
```

### 死锁

#### 死锁的四个必要条件

- 互斥:资源一次只能被一个进程使用,其他进程申请被使用进程必须等待
- 请求和保持:进程持有资源,但又请求了其他资源,请求的资源被其他进程占有,因此该进程被挂起等待,但不释放自己已经占有的资源
- 不可抢占:进程申请的资源在未使用完前,不能被其他进程抢占,只能由该进程主动释放
- 循环等待:资源的循环请求链,链中的每一个进程都在等待下一个进程占有的资源

#### 死锁的预防

- 破坏互斥:将互斥的资源改为共享可用

- 破坏不可抢占:

  - 当某个进程请求的资源得不到满足的时候,必须立即释放保持的所有资源
  - 当某个进程请求的资源被其他进程占有的时候,可由操作系统将请求的资源强行剥夺

- 破坏请求和保持条件:

  静态分配:进程在运行前,一次申请完全部需要的资源,如果资源不满足,则不运行,一旦运行这些资源就归该进程

- 破坏循环等待条件:

  为资源进行编号,进程在请求资源的时候只能按照资源编号递增的顺序请求资源.

#### 死锁的检测和恢复

检测:

- 每种类型一个资源

  将进程和资源构建一个资源分配有向图,然后检查该有向图中是否存在环.

  若存在环则存在死锁,反正则不存在

- 每种类型多个资源

  构建`现有资源矩阵E`,`可用资源矩阵A`,`当前分配矩阵C`以及`请求矩阵R`

  从`R`中寻找一个请求的资源满足`A`的进程,然后将`C`的该进程的资源加到`A`上.(这一步的意思是从请求中寻找一个可用满足运行条件的进程,为其分配资源然后运行,运行结束后将资源),然后标记该进程

  最后,所有未被标记的进程都是死锁进程.

恢复

- 抢占恢复:将占有的资源分配给另一个进程
- 回滚恢复:将进程恢复到一个更早的时间点,然后将资源分配给其他进程
- 杀死进程

#### 鸵鸟算法

不管死锁的发生和解除死锁,直接重启

### 进程与线程关系

进程:是程序的一次执行,是操作系统分配资源的基本单位.

线程:是操作系统调度的基本单位.

区别与联系:

- 进程拥有操作系统分配的资源,但线程没有分配,只能使用它所属进程的资源.
- 线程是调度的基本单位,线程的切换不会引起进程的切换,消耗比进程切换小
- 线程之间的通信可以借助进程中的资源,而进程之间的通信需要借助IPC

### 线程实现模型

#### 用户级线程(M:1)

将多个线程放在用户空间中，对应一个系统线程，线程之间由用户空间来进行调度，因此不需要陷入内核状态。但由于内核线程无法感知用户线程，一旦一个用户线程因为某些原因阻塞，则整个进程就阻塞，即使其他线程是可以运行的。由于没有时间中断，因此一个线程开始执行，那么其他线程将无法执行，除非运行的线程主动让出cpu进行新的调度。

#### 内核级线程(1:1)

将一个用户线程对应一个内核线程，线程由内核进行调度。当用户进程的一个线程阻塞时，内核可以调度其他线程来运行。但由于一个用户线程对应一个内核线程，因此线程之间的调度需要进入内核状态，并且用户线程过多的启动新线程，会影响系统对线程的调度性能。linux使用该线程模型。

#### 混合线程(M:N)

将用户线程与内核线程多路复用，一个进程与多个内核线程关联，多个用户线程可以运行在一个内核线程上。内核只需要调度内核线程，用户线程之间的调度由用户空间完成。

***x:y表示x个用户线程对应y个内核线程***

![](http://qiniu.qraffa.cn/TOIMGba0cd1230081812N.png)